:- module(prime_gen, [prime_gen_new/1, prime_gen_new/2, prime_gen_next/3]).

/**
* Implementation of a prime number generator.
*
* The general approach followed here is the one described in [1] for the Haskell
* language.
*
* The module offers the following routines:
*   * prime_gen_new(-PrimeGen): creates a new prime number generator PrimeGen.
*
*   * prime_gen_new(+Ps, -PrimGen): creates a new prime number generator
*     PrimeGen using the sequence Ps of the first prime numbers as a bootstrap.
*
*   * prime_gen_next(PrimeGen, PrimeGen1, Prime): generates a new prime number
*     Prime using PrimGen. PrimeGen1 is the updated version of PrimeGen.
*
* [1] O'Neill, Melissa, The Genuine Sieve of Eratosthenes, J. Funct. Program.,
*     (2009), 19. 95-106. 10.1017/S0956796808007004.
*/

%-------------------------------------------------------------------------------
% Prime Candidate Generator (PCG)
%-------------------------------------------------------------------------------
% A PCG is a number wheel initialised to generate numbers that are not multiple
% of the prime numbers provided at its creation.
%-------------------------------------------------------------------------------

/**
* pcg_new(+Ps, -PCG)
*
* Creates a new prime candidate generator PCG using the initial sequence of
* prime numbers Ps. In practice, PCG is used to generate all the natural numbers
* that are both larger and not a multiple of any element of Ps.
*
* Note: Ps is not checked to be an initial sequence of prime numbers.
*/

pcg_new(Ps, PCG) :-
  product(Ps, Size),
  up_to(Size, L1s),
  rm_multiples_of(Ps, L1s, L2s),
  pcg_step_beyond(pcg(0, Size, L2s, L2s), Ps, PCG).


/**
* pcg_value(+PCG, -Val)
*
* Returns the current value Val of the generator PCG.
*/

pcg_value(pcg(B, _, [E|_], _), Val) :- Val is B+E.


/**
* pcg_step(+PCG0, -PCG1)
*
* PCG1 is the outcome of stepping PCG0.
*/

pcg_step(pcg(B, S, [_, E2 | Es], All), pcg(B, S, [E2|Es], All)).

pcg_step(pcg(B0, S, [_], All), pcg(B1, S, All, All)) :- B1 is B0 + S.


/**
* pcg_step_beyond(+PCG0, +Val, -PCG1)
*
* PCG1 is the outcome of stepping PCG0 until its value gets larger than Val.
*/

pcg_step_beyond(PCG0, [N|Ns], PCG2) :-
  pcg_value(PCG0, C),
  C =< N,
  pcg_step(PCG0, PCG1),
  pcg_step_beyond(PCG1, [N|Ns], PCG2).

pcg_step_beyond(PCG0, [N|Ns], PCG1) :-
  pcg_value(PCG0, C),
  C > N,
  pcg_step_beyond(PCG0, Ns, PCG1).

pcg_step_beyond(PCG, [], PCG).


%-------------------------------------------------------------------------------
% Single Prime Multiple Generator (SPMG)
%-------------------------------------------------------------------------------
% A SPMG instance generates the sequence of multiples of a prime number that
% will be generated by the PCG instance provided at construction.
%
% In practice, the sequence generated is the product of the Prime by the
% sequence generated by PCG.
%-------------------------------------------------------------------------------

/**
 * spmg_new(+PCG, -SPMG)
 *
 * Creates a new SPMG from a PCG. The current value of the latter is assumed to
 * be prime.
 */

spmg_new(PCG, spmg(Prime, PCG)) :- pcg_value(PCG, Prime).

/**
 * spmg_value(+SPMG, -Val)
 *
 * Val is the current value of SPMG.
 */

spmg_value(spmg(Prime, PCG), Val) :- pcg_value(PCG, Cur), Val is Cur * Prime.


/**
 * spmg_step(SPMG0, SPMG1)
 *
 * SPMG1 is the outcome of stepping SPMG0.
 */
spmg_step(spmg(Prime, PCG0), spmg(Prime, PCG1)) :- pcg_step(PCG0, PCG1).


/**
 * spmg_step_up_to_value(SPMG0, VAL, SPMG1)
 *
 * SPMG1 is the outcome of stepping SPMG0 while its current value stays smaller
 * than Val.
 */

spmg_step_up_to_value(SPMG0, Val, SPMG2) :- spmg_value(SPMG0, Cur), Cur <
  Val, spmg_step(SPMG0, SPMG1), spmg_step_up_to_value(SPMG1, Val, SPMG2).

spmg_step_up_to_value(SPMG, Val, SPMG) :- spmg_value(SPMG, Cur), Cur >= Val.


%-------------------------------------------------------------------------------
% Prime Generator (PG)
%
% A PG generates the sequence of the prime numbers.
%-------------------------------------------------------------------------------

/**
 * prime_gen_new(PG)
 * prime_gen_new(Primes, PG)
 *
 * Creates a new prime generator PG. In the second version the initial sequence
 * of prime numbers Primes is used to bootstrap PG. In the first version, the
   sequence 2, 3, 5, 7, 11, 13 is used as default prime sequence.
 */

prime_gen_new(PG) :- prime_gen_new([2, 3, 5, 7, 11, 13], PG).

prime_gen_new(Ps, pg0(Ps, Ps)).


/**
 * prime_gen_next(PG0, PG1, P)
 *
 * P is the prime number generated by PG0 and PG1 is the next prime generator.
 */

prime_gen_next(pg0([Prime|Ps], Ps0), pg0(Ps, Ps0), Prime).

prime_gen_next(pg0([], Ps0), pg(PCG, Heap), Prime) :- pcg_new(Ps0, PCG),
  pcg_value(PCG, Prime), spmg_new(PCG, SPMG), heap_new(SPMG, Heap).

prime_gen_next(pg(PCG0, Heap0), PG1, Prime) :-
  Heap0 \= void,
  pcg_step(PCG0, PCG1),
  pcg_value(PCG1, Candidate),
  heap_iterate_up_to_value(Heap0, Candidate, Heap1),
  heap_root(Heap1, Root1),
  spmg_value(Root1, CurHeap1),
  ( Candidate < CurHeap1, % Candidate is a new prime
    Prime = Candidate,
    spmg_new(PCG1, SPMG),
    heap_add(Heap1, SPMG, Heap2),
    PG1 = pg(PCG1, Heap2);

    Candidate =:= CurHeap1, % Candidate is a multiple of a prime
    prime_gen_next(pg(PCG1, Heap1), PG1, Prime)
  ).

%-------------------------------------------------------------------------------
% Binary Tree Heap for SPMGs
%
% The heap nodes contain SPMG instances, and the heap is such that no element
% has a smaller current value than the root element; as usual, this applies
% recursively to the left and right branches. The heap allows for adding new
% SPMGs, and replacing the heap root SPMG after it has been stepped.
%-------------------------------------------------------------------------------

/**
 * heap_new(+SPMG, -HEAP)
 *
 * Creates a new one-node heap containing SPMG.
 */

heap_new(SPMG, heap(SPMG, 1, void, void)).


/**
 * heap_root(+Heap, -Root).
 *
 * Root is the root element of Heap.
 */

heap_root(heap(Root, _, _, _), Root).


/**
 * heap_size(+Heap, -Size).
 *
 * Size is the size of Heap, that is, the number of nodes it contains.
 */

heap_size(heap(_, Size, _, _), Size). heap_size(void, 0).


/**
 * heap_optional_value(+Heap, +Default, -Val).
 *
 * Val is the value of the SPMG at the root of the heap, or Default if the heap
 * is empty. That latter case arrives by going down the tree and reaching the
 * leaves, which are represented by 'void' heaps without a node.
 */

heap_optional_value(void, Default, Default).

heap_optional_value(heap(SPMG, _,_, _), _, Val) :- spmg_value(SPMG, Val).


/**
 * heap_iterate_up_to_value(+Heap0, +Val, -Heap1)
 *
 * Iterates the root element and update the heap accordingly while the value of
 * the root is smaller than Val.
 */

heap_iterate_up_to_value(Heap, Val, Heap) :- heap_root(Heap, Root),
  spmg_value(Root, Cur), Val =< Cur.

heap_iterate_up_to_value(Heap0, Val, Heap2) :- heap_root(Heap0, SPMG0),
  spmg_value(SPMG0, Cur), Cur < Val, spmg_step_up_to_value(SPMG0, Val, SPMG1),
  heap_update_root(Heap0, SPMG1, Heap1), heap_iterate_up_to_value(Heap1, Val,
  Heap2).


/**
 * heap_update_root(+Heap0, +SPMG, -Heap1)
 *
 * Heap1 is the result of replacing the root of Heap0 by SPMG, and updating
 * Heap0 accordingly.
 */

heap_update_root(heap(_, W, Left, Right), SPMG, heap(SPMG, W, Left, Right)) :-
  spmg_value(SPMG, Val), heap_optional_value(Left, Val, LVal),
  heap_optional_value(Right, Val, RVal), Val =< LVal, Val =< RVal.

heap_update_root(heap(_, W, Left, Right), SPMG, heap(Root1, W, Left1, Right)) :-
  spmg_value(SPMG, Val), heap_optional_value(Left, Val, LVal),
  heap_optional_value(Right, Val, RVal), LVal < Val, LVal =< RVal,
  heap_root(Left, Root1), heap_update_root(Left, SPMG, Left1).

heap_update_root(heap(_, W, Left, Right), SPMG, heap(Root1, W, Left, Right1)) :-
  spmg_value(SPMG, Val), heap_optional_value(Left, Val, LVal),
  heap_optional_value(Right, Val, RVal), RVal < Val, RVal < LVal,
  heap_root(Right, Root1), heap_update_root(Right, SPMG, Right1).


/**
 * heap_add(+Heap0, +SPMG, -Heap1)
 *
 * Heap1 is the result of adding SPMG to Heap0.
 */

heap_add(void, SPMG, Heap) :- heap_new(SPMG, Heap).

heap_add(heap(Root, Size, Left, Right), SPMG, Heap) :- spmg_value(SPMG, Val),
  spmg_value(Root, HeapVal), Size1 is Size + 1, HeapVal =< Val, heap_size(Left,
  LSize), heap_size(Right, RSize),
  (
    LSize =< RSize,
    heap_add(Left, SPMG, Left1),   Heap = heap(Root, Size1, Left1, Right)
    ;
    LSize > RSize,
    heap_add(Right, SPMG, Right1), Heap = heap(Root, Size1, Left, Right1)
  ).

heap_add(heap(Root, Size, Left, Right), SPMG, Heap) :- spmg_value(SPMG, Val),
  spmg_value(Root, HeapVal), Size1 is Size + 1, Val < HeapVal, heap_size(Left,
  LSize), heap_size(Right, RSize),
  (
    LSize =< RSize,
    heap_add(Left, Root, Left1),   Heap = heap(SPMG, Size1, Left1, Right)
    ;
    LSize > RSize,
    heap_add(Right, Root, Right1), Heap = heap(SPMG, Size1, Left, Right1)
  ).


%-------------------------------------------------------------------------------
% Helper procedures.
%-------------------------------------------------------------------------------

/**
 * product(+Ns, -Res)
 *
 * Res is the product of the Ns elements.
*/

product(Ns, Res) :- product(Ns, 1, Res).
product([N|Ns], Acc0, Res) :- Acc1 is Acc0 * N, product(Ns, Acc1, Res).
product([], Acc, Acc).


/**
 * up_to(+Length, ?Ls)
 *
 * Ls is the sequence 0, 1, ..., Length-1.
*/

up_to(Length, Ls) :- up_to(Length, [], Ls).
up_to(Length, Acc, Acc) :- Length =:= 0.
up_to(Length, Acc, Ls) :-
  Length > 0,
  N is Length-1,
  up_to(N, [N|Acc], Ls).


/**
 * rm_multiples_of(+Ns, +L0s, -L1s)
 *
 * L1s is the list L0s without the multiples of the elements of Ns.
*/

rm_multiples_of(_, [], []).
rm_multiples_of(Ns, [L|L0s], L1s) :-
  is_multiple_of_any(L, Ns), !,
  rm_multiples_of(Ns, L0s, L1s).
rm_multiples_of(Ns, [L|L0s], [L|L1s]) :-
  rm_multiples_of(Ns, L0s, L1s).

/**
 * is_multiple_of_any(+M, +Ns)
 *
 * M is a multiple of an element of Ns.
*/

is_multiple_of_any(M, [N|Ns]) :-
  Rest is M mod N,
  ( Rest =:= 0, !;
    is_multiple_of_any(M, Ns)).
